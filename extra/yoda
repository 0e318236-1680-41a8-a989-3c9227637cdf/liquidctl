#!/usr/bin/env python3

"""Adjust device speeds dynamically, with software.

Periodicatly adjusts pump or fan speeds according to user-specified
profiles.

Different sensors can be used for each channel; use show-sensors to view the
available sensors for use with a device.

Usage:
  yoda [options] show-sensors
  yoda [options] control (<channel> with <profile> on <sensor> [and])...
  yoda --help
  yoda --version

Options:
  --interval <seconds>     Update interval in seconds [default: 3]
  -m, --match <substring>  Filter devices by description substring
  -n, --pick <number>      Pick among many results for a given filter
  --vendor <id>            Filter devices by vendor id
  --product <id>           Filter devices by product id
  --release <number>       Filter devices by release number
  --serial <number>        Filter devices by serial number
  --bus <bus>              Filter devices by bus
  --address <address>      Filter devices by address in bus
  --usb-port <port>        Filter devices by USB port in bus
  --pick <number>          Pick among many results for a given filter
  -v, --verbose            Output additional information
  -g, --debug              Show debug information on stderr
  --hid <module>           Override API for USB HIDs: usb, hid or hidraw
  --legacy-690lc           Use Asetek 690LC in legacy mode (old Krakens)
  --version                Display the version number
  --help                   Show this message

Examples:
  yoda --match grid show-sensors
  yoda --match grid control fan1 with '(20,20),(35,100)' on nct6793.systin
  yoda --match kraken show-sensors
  yoda --match kraken control pump with '(20,50),(50,100)' on istats.cpu and fan with '(20,25),(35,100)' on _internal.liquid

Requirements:
  all platforms  liquidctl, including the Python APIs (pip install liquidctl)
  Linux/FreeBSD  psutil (pip install psutil)
  macOS          iStats (gem install iStats)
  Windows        none, system sensors not yet supported

Changelog:
  0.0.1  Generalization of krakencurve-poc 0.0.2 to multiple devices.
"""

import ast
import logging
import sys
import time

from docopt import docopt

import liquidctl.cli as _borrow
from liquidctl.util import normalize_profile, interpolate_profile
from liquidctl.driver import *

if sys.platform == 'darwin':
    import re
    import subprocess
elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    import psutil

VERSION = '0.0.1'
LOGGER = logging.getLogger(__name__)

INTERNAL_CHIP_NAME = '_internal'


def read_sensors(device):
    sensors = {}
    if device:
        for k, v, u in device.get_status():
            if u == '°C':
                sensor_name = k.lower().replace(' ', '_').replace('_temperature', '')
                sensors[f'{INTERNAL_CHIP_NAME}.{sensor_name}'] = v
    if sys.platform == 'darwin':
        istats_stdout = subprocess.check_output(['istats']).decode('utf-8')
        for line in istats_stdout.split('\n'):
            if line.startswith('CPU'):
                cpu_temp = float(re.search(r'\d+\.\d+', line).group(0))
                sensors['istats.cpu'] = cpu_temp
                break
    elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
        for m, li in psutil.sensors_temperatures().items():
            for label, current, _, _ in li:
                sensor_name = label.lower().replace(' ', '_')
                sensors[f'{m}.{sensor_name}'] = current
    return sensors


def show_sensors(device):
    print('{:<60}  {:>18}'.format('Sensor identifier', 'Temperature'))
    print('-' * 80)
    sensors = read_sensors(device)
    for k, v in sensors.items():
        print('{:<70}  {:>6}{}'.format(k, v, '°C'))


def parse_profile(arg, mintemp=0, maxtemp=100, minduty=0, maxduty=100):
    """Parse, validate and normalize a temperature–duty profile.

    >>> parse_profile('(20,30),(30,50),(34,80),(40,90)', 0, 60, 25, 100)
    [(20, 30), (30, 50), (34, 80), (40, 90), (60, 100)]
    >>> parse_profile('35', 0, 60, 25, 100)
    [(0, 35), (59, 35), (60, 100)]

    The profile is validated in structure and acceptable ranges.  Duty is
    checked against `minduty` and `maxduty`.  Temperature must be between
    `mintemp` and `maxtemp`.

    >>> parse_profile('(20,30),(50,100', 0, 60, 25, 100)
    Traceback (most recent call last):
        ...
    ValueError: Profile must be comma-separated (temperature, duty) tuples
    >>> parse_profile('(20,30),(50,100,2)', 0, 60, 25, 100)
    Traceback (most recent call last):
        ...
    ValueError: Profile must be comma-separated (temperature, duty) tuples
    >>> parse_profile('(20,30),(50,97.6)', 0, 60, 25, 100)
    Traceback (most recent call last):
        ...
    ValueError: Duty must be integer number between 25 and 100
    >>> parse_profile('(20,15),(50,100)', 0, 60, 25, 100)
    Traceback (most recent call last):
        ...
    ValueError: Duty must be integer number between 25 and 100
    >>> parse_profile('(20,30),(70,100)', 0, 60, 25, 100)
    Traceback (most recent call last):
        ...
    ValueError: Temperature must be integer number between 0 and 60

    """
    try:
        val = ast.literal_eval('[' + arg + ']')
        if len(val) == 1 and isinstance(val[0], int):
            # for arg == '<number>' set fixed duty between mintemp and maxtemp - 1
            val = [(mintemp, val[0]), (maxtemp - 1, val[0])]
    except:
        raise ValueError("Profile must be comma-separated (temperature, duty) tuples")
    for step in val:
        if not isinstance(step, tuple) or len(step) != 2:
            raise ValueError("Profile must be comma-separated (temperature, duty) tuples")
        temp, duty = step
        if not isinstance(temp, int) or temp < mintemp or temp > maxtemp:
            raise ValueError("Temperature must be integer between {} and {}".format(mintemp, maxtemp))
        if not isinstance(duty, int) or duty < minduty or duty > maxduty:
            raise ValueError('Duty must be integer between {} and {}'.format(minduty, maxduty))
    return normalize_profile(val, critx=maxtemp)


def control(device, channels, profiles, sensors, update_interval):
    LOGGER.info('device: %s on bus %s, address %s', device.description, device.bus, device.address)
    for channel, profile, sensor in zip(channels, profiles, sensors):
        LOGGER.info('channel: %s following profile %s on %s', channel, str(profile), sensor)
    LOGGER.info('update interval: %d s', update_interval)
    try:
        # more efficient and safer API, but only supported by very few devices
        set_duty = device.set_instantaneous_speed
    except AttributeError:
        set_duty = device.set_fixed_speed
    LOGGER.info('Starting')
    while True:
        sensor_data = read_sensors(device)
        for channel, profile, sensor in zip(channels, profiles, sensors):
            duty = interpolate_profile(profile, sensor_data[sensor])
            LOGGER.info('%s control (%s): %.1f°C => %d%%', channel, sensor, sensor_data[sensor], duty)
            # TODO basic error handling and recovery
            set_duty(channel, duty)
        time.sleep(update_interval)


if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == 'doctest':
        import doctest
        doctest.testmod(verbose=True)
        sys.exit(0)

    args = docopt(__doc__, version='yoda v{}'.format(VERSION))

    if args['--debug']:
        args['--verbose'] = True
        logging.basicConfig(level=logging.DEBUG, format='[%(levelname)s] %(name)s: %(message)s')
        LOGGER.debug('yoda v%s', VERSION)
        import liquidctl.version
        LOGGER.debug('liquidctl v%s', liquidctl.version.__version__)
    elif args['--verbose']:
        # keep basic logging level at WARNING, but set this module's LOGGER to INFO
        logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
        LOGGER.setLevel(logging.INFO)
    else:
        logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
        sys.tracebacklimit = 0

    frwd = _borrow._make_opts(args)
    selected = list(find_liquidctl_devices(**frwd))
    if len(selected) > 1:
        raise SystemExit('Too many devices, filter or select one (see: liquidctl --help)')
    elif len(selected) == 0:
        raise SystemExit('No devices matches available drivers and selection criteria')

    device = selected[0]
    device.connect()
    try:
        if args['show-sensors']:
            show_sensors(device)
        elif args['control']:
            control(device, args['<channel>'], list(map(parse_profile, args['<profile>'])),
                    args['<sensor>'], update_interval=int(args['--interval']))
        else:
            raise Exception('Nothing to do')
    except KeyboardInterrupt:
        LOGGER.info('Stopped by user')
    finally:
        device.disconnect()
